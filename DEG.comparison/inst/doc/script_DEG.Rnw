%\VignetteIndexEntry{RNA-Seq Report Template}
%\VignetteDepends{NBPSeq, baySeq, systemPipeR, ggplot2}
%\VignetteKeywords{DEGs, pipeline, reports}
%\VignettePackage{DEG.comparison}

% Latex compile
% Sweave("script_DEG.Rnw"); system("pdflatex script_DEG.tex; bibtex script_DEG; pdflatex script_DEG.tex; pdflatex script_DEG.tex")
% echo 'Sweave("script_DEG.Rnw")' | R --slave; echo 'Stangle("script_DEG.Rnw")' | R --slave; pdflatex script_DEG.tex;  bibtex script_DEG; pdflatex script_DEG.tex

\documentclass{article}
<<style, eval=TRUE, echo=FALSE, results=tex>>=
BiocStyle::latex(use.unsrturl=FALSE)
@

\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}
\def\bibsection{\section{References}}

\usepackage{graphicx}
\usepackage{color}
\usepackage{hyperref}
\usepackage{url}
\usepackage{float}

%\newcommand{\comment}[1]{}
%\newcommand{\Rfunction}[1]{{\texttt{#1}}}
%\newcommand{\Robject}[1]{{\texttt{#1}}}
%\newcommand{\Rpackage}[1]{{\textit{#1}}}
%\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
%\newcommand{\Rclass}[1]{{\textit{#1}}}
	
% Define header and footer area with fandyhdr package (see: http://www.ctan.org/tex-archive/macros/latex/contrib/fancyhdr/fancyhdr.pdf)
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\rhead{\nouppercase{\leftmark}}
\lhead{\textit{DEG.comparison Report}}
\rfoot{\thepage}

<<echo=FALSE>>=
options(width=95)
unlink("test.db")
@
%\parindent 0in

%\bibliographystyle{plainnat}

\begin{document}
\SweaveOpts{concordance=TRUE}
\title{\Robject{DEG.comparison}: A comparison of methods for DEG analysis of RNA-seq data}
\author{Project ID: RNAseq1 \\
        Author of Report: \\
                          Daniela Cassol (danicassol@gmail.com)\\
                          Lichao Li (lli024@ucr.edu)}
\maketitle

\tableofcontents

\section{Introduction}
This report describes a comparison of 7 methods to detect differentially expressed genes (DEG) in RNA-seq data from cell-type specific RNAs analysis study in \textit{Arabidopsis thaliana} engaged by Jiao Y et. al \citep{Jiao2010-ew}. 
The first part of this report will be described the workflow \Robject{systemPipeR} package \citep{Girke2014-oy}. \Robject{systemPipeR} was used to obtain the table of the counts reads and then the workflow created in the package DEG.comparison.

\section{\Robject{systemPipeR}}

\subsection{Environment settings and input data}
Typically, the user wants to record here the sources and versions of the reference genome sequence along with the corresponding annotations. In the provided sample data set all data inputs are stored in a \Robject{data} subdirectory and all results will be written to a separate \Robject{results} directory, while the \Robject{systemPipeRNAseq.Rnw} script and the \Robject{targets} file are expected to be located in the parent directory. The R session is expected to run from this parent directory.

The chosen data set \href{http://www.ncbi.nlm.nih.gov/sra/?term=SRP003234}{\textcolor{blue}{SRP003234}} contains 16 singel-end (SE) read sets from \textit{Arabidposis thaliana} \citep{Jiao2010-ew}.

\subsection{Required packages and resources}
The \Rpackage{DEG.comparison} package needs to be loaded to perform the analysis steps shown in this report \citep{Cassol-br}. 
<<eval=TRUE, keep.source=TRUE>>=
library(DEG.comparison)
@

\subsection{Experiment definition provided by \Robject{targets} file}
The \href{run:targets.txt}{\Robject{targets}} file defines all FASTQ files and sample comparisons of the analysis workflow. 
<<eval=TRUE, keep.source=TRUE>>=
library(systemPipeR)
targetspath <- system.file("extdata", "targets.txt", package="DEG.comparison")
targets <- read.delim(targetspath, comment.char = "#")
targets
cmp <- readComp(file=targetspath, format="matrix", delim="-")
@

\subsection{Structure of \Robject{param} file and \Robject{SYSargs} container}
The \Robject{param} file defines the parameters of the command-line software. The following shows the format of a sample \Robject{param} file provided by this package. 
<<eval=TRUE, keep.source=TRUE>>=
parampath <- system.file("extdata", "tophat.param", package="DEG.comparison")
read.delim(parampath, comment.char = "#")
@
\noindent The \Rfunction{systemArgs} function imports the definitions of both the \Robject{param} file and the \Robject{targets} file, and stores all relevant information as \Robject{SYSargs} object. To run the pipeline without command-line software, one can assign \Rfunarg{NULL} to \Rfunarg{sysma} instead of a \Robject{param} file. In addition, one can start the \Rpackage{systemPipeR} workflow with pregenerated BAM files by providing a targets file where the \Robject{FileName} column gives the paths to the BAM files and \Rfunarg{sysma} is assigned \Rfunarg{NULL}.
<<eval=TRUE, keep.source=TRUE>>=   
args <- systemArgs(sysma=parampath, mytargets=targetspath)
args
@
\noindent Several accessor functions are available that are named after the slot names of the \Robject{SYSargs} object class.
<<eval=TRUE, keep.source=TRUE>>=   
names(args)
modules(args)
cores(args)
outpaths(args)[1]
sysargs(args)[1]
@
\noindent The content of the \Robject{param} file can be returned as JSON object as follows (requires \Rpackage{rjson} package).
<<eval=TRUE, keep.source=TRUE>>=   
systemArgs(sysma=parampath, mytargets=targetspath, type="json")
@

\subsection{Read preprocessing}

\subsubsection{Construct \Robject{SYSargs} object from \Robject{param} and \Robject{targets} files.}
<<eval=FALSE, keep.source=TRUE>>=
trim.param <- system.file("extdata", "trim.param", package="DEG.comparison")
trim.param <- read.delim(trim.param, comment.char = "#")
args <- systemArgs(sysma="trim.param", mytargets=targetspath)
@

\subsubsection{\Rfunction{preprocessReads}}
The function \Rfunction{preprocessReads} allows to apply predefined or custom read preprocessing functions to all FASTQ files referenced in a \Robject{SYSargs} container, such as quality filtering or adaptor trimming routines. The paths to the resulting output FASTQ files are stored in the \Robject{outpaths} slot of the \Robject{SYSargs} object. Internally, \Rfunction{preprocessReads} uses the \Rfunction{FastqStreamer} function from the \Rpackage{ShortRead} package to stream through large FASTQ files in a memory-efficient manner. The following example performs adaptor trimming with the \Rfunction{trimLRPatterns} function from the \Rpackage{Biostrings} package.
After the trimming step a new targets file is generated (here \Robject{targets\_trim.txt}) containing the paths to the trimmed FASTQ files. The new targets file can be used for the next workflow step with an updated \Robject{SYSargs} instance, \textit{e.g.} running the NGS alignments using the trimmed FASTQ files. 
<<eval=FALSE, keep.source=TRUE>>=
preprocessReads(args=args, Fct="trimLRPatterns(Rpattern='GCCCGGGTAA', subject=fq)", 
                batchsize=100000, overwrite=TRUE, compress=TRUE)
writeTargetsout(x=args, file="targets_trim.txt")
@

The following example shows how one can design a custom read preprocessing function using utilities provided by the \Rpackage{ShortRead} package, and then run it
in batch mode with the \Rfunction{preprocessReads} function.
<<eval=FALSE, keep.source=TRUE>>=
filterFct <- function(fq) {
  filter1 <- nFilter(threshold=1) # Keeps only reads without Ns
	filter2 <- polynFilter(threshold=20, nuc=c("A","T","G","C")) # Removes low complexity reads 
	filter <- compose(filter1, filter2)
	fq[filter(fq)]
}
preprocessReads(args=args, Fct="filterFct(fq)", batchsize=100000)
@

\subsubsection{FASTQ quality report}
The following \Rfunction{seeFastq} and \Rfunction{seeFastqPlot} functions generate and plot a series of useful quality statistics for a set of FASTQ files including per cycle quality box plots, base proportions, base-level quality trends, relative k-mer diversity, length and occurrence distribution of reads, number of reads above quality cutoffs and mean quality distribution.  
<<eval=FALSE, keep.source=TRUE>>=
fqlist <- seeFastq(fastq=infile1(args), batchsize=10000, klength=8)
pdf("./results/fastqReport.pdf", height=18, width=4*length(fqlist))
seeFastqPlot(fqlist)
dev.off()
@
\begin{figure}[H]
  \centering
   \includegraphics[width=18cm]{fastqReport.pdf}
   \caption{QC report for 19 FASTQ files.}
   \label{fig:fastqreport}
\end{figure}

\subsection{Alignments}
\subsubsection{Read mapping with \Rfunction{Bowtie2/Tophat2}}
The NGS reads of this project will be aligned against the reference genome sequence using \Robject{Bowtie2/TopHat2} \citep{Kim2013-vg, Langmead2012-bs}. The parameter settings of the aligner are defined in the \Robject{tophat.param} file.
<<eval=FALSE, keep.source=TRUE>>=
args <- systemArgs(sysma="tophat.param", mytargets="targets.txt")
sysargs(args)[1] # Command-line parameters for first FASTQ file
@
Submission of alignment jobs to compute cluster, here using 72 CPU cores (19 \Robject{qsub} processes each with 4 CPU cores).
<<eval=FALSE, keep.source=TRUE>>=
moduleload(modules(args))
system("bowtie2-build ./data/TAIR10_chr_all.fas ./data/TAIR10_chr_all.fas")
bampaths <- runCommandline(args=args)
file.copy(paste0("./.BatchJobs.R"), ".")
file.copy(paste0("./torque.tmpl"), ".")
resources <- list(walltime="20:00:00", nodes=paste0("1:ppn=", cores(args)), memory="16gb")
reg <- clusterRun(args, conffile=".BatchJobs.R", template="torque.tmpl", Njobs=18, runid="01", 
                  resourceList=resources)
showStatus(reg)
@
Check whether all BAM files have been created
<<eval=FALSE, keep.source=TRUE>>=
file.exists(outpaths(args))
sapply(1:length(args), function(x) loadResult(reg, x)) # Works after job completion
@

\subsection{Read and alignment stats}
The following provides an overview of the number of reads in each sample and how many of them aligned to the reference.
<<eval=FALSE, keep.source=TRUE>>=
read_statsDF <- alignStats(args=args) 
write.table(read_statsDF, "results/alignStats.xls", row.names=FALSE, quote=FALSE, sep="\t")
@
<<eval=TRUE, keep.source=TRUE>>=
read.table(system.file("extdata", "alignStats.xls", package="DEG.comparison"), header=TRUE)[1:4,]
@

\subsection{Create symbolic links for viewing BAM files in IGV}
The \Rfunction{symLink2bam} function creates symbolic links to view the BAM alignment files in a genome browser such as IGV. The corresponding URLs are written to a file with a path specified under \Robject{urlfile}, here \href{run:./results/IGVurl.txt}{IGVurl.txt}.
<<eval=FALSE, keep.source=TRUE>>=
symLink2bam(sysargs=args, htmldir=c("~/.html/", "cassol_GEN242/"), 
            urlbase="http://biocluster.ucr.edu/~dcassol/", urlfile="IGVurl.txt")

@

\subsection{Read quantification per annotation range}
\subsubsection{Read counting with \Rfunction{summarizeOverlaps} in parallel mode using multiple cores}
Reads overlapping with annotation ranges of interest are counted for each sample using the \Rfunction{summarizeOverlaps} function \citep{Lawrence2013-kt}. The read counting is preformed for exonic gene regions in a non-strand-specific manner while ignoring overlaps among different genes. Subsequently, the expression count values are normalized by \textit{reads per kp per million mapped reads} (RPKM). The raw read count table (\href{run:./results/countDFeByg.xls}{countDFeByg.xls}) and the correspoding RPKM table (\href{run:./results/rpkmDFeByg.xls}{rpkmDFeByg.xls}) are written to separate files in the \Robject{results} directory of this project. Parallelization is achieved with the \Rpackage{BiocParallel} package, here using 8 CPU cores.
<<eval=FALSE, keep.source=TRUE>>=
library("GenomicFeatures"); library(BiocParallel)
txdb <- makeTranscriptDbFromGFF(file="data/TAIR10_GFF3_genes.gff", format="gff3", dataSource="TAIR", species="Arabidopsis thaliana")
saveDb(txdb, file="./data/tair10.sqlite")

txdb <- loadDb("./data/tair10.sqlite")
eByg <- exonsBy(txdb, by=c("gene"))
bfl <- BamFileList(outpaths(args), yieldSize=50000, index=character())
multicoreParam <- MulticoreParam(workers=4); register(multicoreParam); registered()
# Note: for strand-specific RNA-Seq set 'ignore.strand=FALSE' and for PE data set 'singleEnd=FALSE' 
counteByg <- bplapply(bfl, function(x) summarizeOverlaps(eByg, x, mode="Union",
                                                         ignore.strand=TRUE, 
                                                         inter.feature=TRUE, 
                                                         singleEnd=TRUE))
countDFeByg <- sapply(seq(along=counteByg), function(x) assays(counteByg[[x]])$counts)
rownames(countDFeByg) <- names(rowData(counteByg[[1]])); colnames(countDFeByg) <- names(bfl)
countDFeByg[1:4,1:12]
write.table(countDFeByg, "results/countDFeByg.xls", col.names=NA, quote=FALSE, sep="\t")
rpkmDFeByg <- apply(countDFeByg, 2, function(x) returnRPKM(counts=x, ranges=eByg))
write.table(rpkmDFeByg, "results/rpkmDFeByg.xls", col.names=NA, quote=FALSE, sep="\t")
rpkmDFeByg[1:4,1:7]
@

\subsection{Sample-wise correlation analysis}
The following computes the sample-wise Spearman correlation coefficients from the RPKM normalized expression values. After transformation to a distance matrix, hierarchical clustering is performed with the \Rfunction{hclust} function and the result is plotted as a dendrogram (\href{run:./results/sample_tree.pdf}{sample\_tree.pdf}). 
<<eval=FALSE, keep.source=TRUE>>=
library(ape)
rpkmDFeBygpath <- system.file("extdata", "rpkmDFeByg.xls", package="DEG.comparison")
rpkmDFeByg <- read.delim(rpkmDFeBygpath, row.names=1)
rpkmDFeByg <- rpkmDFeByg[rowMeans(rpkmDFeByg) > 50,]
d <- cor(rpkmDFeByg, method="spearman")
hc <- hclust(as.dist(1-d))
pdf("results/sample_tree.pdf")
plot.phylo(as.phylo(hc), type="p", edge.col="blue", edge.width=2, show.node.label=TRUE, no.margin=TRUE)
dev.off()
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{sample_tree.pdf}
   \caption{Correlation dendrogram of samples.}
   \label{fig:sample_tree}
\end{figure}

\section{\Rpackage{DEG.comparison}}
\subsection{Analysis of differentially expressed genes}
\subsubsection{Structure of data and comparisons}
The data to input to analysis of differentially expressed genes come from \Rpackage{systemePipeR} results and is the first step  in the package  \Robject{DEG.comparison}.

<<eval=FALSE, keep.source=TRUE>>=
##Data input
countDFeBygpath <- system.file("extdata", "countDFeByg.xls", package="DEG.comparison")
countDFeByg <- read.delim(countDFeBygpath, row.names=1)
rpkmDFeBygpath <- system.file("extdata", "rpkmDFeByg.xls", package="DEG.comparison")
rpkmDFeByg <- read.delim(rpkmDFeBygpath, row.names=1)
@
For all the DEGs methods except RPKM, we construct a list contains all the paired comparison of samples. These paired comparison is based on samples from different stage of same organ or different organ in the same stage in this case.
Therefore for the package we need the count table (\Robject{countDFeByg}) and list comparisons (\Robject{Comp3}).

<<eval=FALSE, keep.source=TRUE>>=
##Comparisons
Comp3 <- list(AP1.4_AP1.67=c("AP1.4A","AP1.4B", "AP1.67A", "AP1.67B"), 
              AP3.4_AP3.67=c("AP3.4A","AP3.4B", "AP3.67A" ,"AP3.67B"), 
              AG.4_AG.67=c("AG.4A", "AG.4B", "AG.67A","AG.67B"), 
              AP1.4_AP3.4=c("AP1.4A","AP1.4B", "AP3.4A","AP3.4B"), 
              AP1.4_AG.4=c("AP1.4A", "AP1.4B", "AG.4A", "AG.4B"), 
              AP3.4_AG.4=c("AP3.4A", "AP3.4B", "AG.4A", "AG.4B"), 
              AP1.67_AP3.67=c("AP1.67A","AP1.67B", "AP3.67A", "AP3.67B"), 
              AP1.67_AG.67=c("AP1.67A","AP1.67B", "AG.67A", "AG.67B"), 
              AP3.67_AG.67=c("AP3.67A", "AP3.67B", "AG.67A", "AG.67B"))
@

\subsubsection{DEG1:  Simple Fold Change Method - RPKM}
RPKM (Reads Per Kilobase per Million mapped reads) is a method of quantifying gene expression by simply normalizing for total read length and the number of sequencing reads \citep{Mortazavi2008}. 
For running DEGs directly from RPKM counts reads, we need to set two list.

<<eval=FALSE, keep.source=TRUE>>=
##Settings
Comp1 <- list(Factor=(Reduce(union, targets$Factor)), Sample=c(colnames(rpkmDFeByg)), 
              group=c(1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8))

Comp2 <- list(AP1.4_AP1.67=c("AP1.4", "AP1.67"), AP3.4_AP3.67=c("AP3.4", "AP3.67"), 
              AG.4_AG.67=c("AG.4", "AG.67"), AP1.4_AP3.4=c("AP1.4", "AP3.4"), 
              AP1.4_AG.4=c("AP1.4", "AG.4"), AP3.4_AG.4=c("AP3.4", "AG.4"), 
              AP1.67_AP3.67=c("AP1.67", "AP3.67"), AP1.67_AG.67=c("AP1.67", "AG.67"), 
              AP3.67_AG.67=c("AP3.67", "AG.67"))
@
In our package, we create \Rfunction{run{\_}RPKM} to compute mean values for replicates samples and log2 values of fold change between paired comparisons, then collect significant genes using \Rfunction{filterDEG{\_}logFC}.

<<eval=FALSE, keep.source=TRUE>>=
RPKM_FC <- run_RPKM (rpkmDFeByg, Comp1, Comp2)
write.table(RPKM_FC, "./results/RPKM_FC.xls", quote=FALSE, sep="\t", col.names = NA)
pdf("./results/DEG_list_RPKM.pdf") 
DEG_list_RPKM <- filterDEG_logFC(degDF=RPKM_FC, filter=c(Fold=2), method="RPKM")
dev.off()
DEG_list_RPKM$Summary[1:4,]
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{DEG_list_RPKM.pdf}
   \caption{Up and down regulated DEGs.}
   \label{fig:DEG_list_RPKM}
\end{figure}

\subsubsection{DEG2: edgeR}
edgeR is a DEG methods that implement a range of statistical methodology based on the negative binomial distributions, 
including empirical Bayes estimation, exact tests, generalized linear models and quasi-likelihood tests \citep{McCarthy2012-al}. 
Here we use generalized linear models (glms) method from the \Rpackage{edgeR} package \citep{Robinson2010-uk}, which is suitable for multifactor experiments of any complexity.
The function \Rfunction{run{\_}edgeR} is defined in \Rpackage{systemPipeR} package \citep{Girke2014-oy}. The sample comparisons used by this analysis are defined in the header lines of the \href{run:targets.txt}{\Robject{targets}} file starting with \texttt{<CMP>}.

<<eval=FALSE, keep.source=TRUE>>=
edgeDF <- run_edgeR(countDF=countDFeByg, targets=targets, cmp=cmp[[1]], independent=FALSE, mdsplot="")
write.table(edgeDF, "results/edgeDF.xls", col.names=NA, quote=FALSE, sep="\t")
pdf("./results/DEG_list_edgeR.pdf") 
DEG_list_edgeR <- filterDEGnew(degDF=edgeDF, filter=c(Fold=2, FDR=1), method="edgeR")
dev.off()
DEG_list_edgeR$Summary[1:4,]
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{DEG_list_edgeR.pdf}
   \caption{Up and down regulated DEGs.}
   \label{fig:DEG_list_edgeR}
\end{figure}

\subsubsection{DEG3: DESeq2}
DESeq2 estimate variance-mean dependence in count data and test for differential expression based on a model using the negative binomial distribution \citep{Love2014-sh}. 
Similar to edgeR, he function  \Rfunction{run{\_}DESeq2} is defined in \Rpackage{systemPipeR} package \citep{Girke2014-oy}.
<<eval=FALSE, keep.source=TRUE>>=
deseq2DF <- run_DESeq2(countDF=countDFeByg, targets=targets, cmp=cmp[[1]], independent=FALSE)
write.table(deseq2DF, "results/deseq2DF.xls", col.names=NA, quote=FALSE, sep="\t")
pdf("./results/DEG_list_DESeq2.pdf")
DEG_list_DESeq2 <- filterDEGnew(degDF=deseq2DF, filter=c(Fold=2, FDR=1), method="DESeq2")
dev.off()
DEG_list_DESeq2$Summary[1:4,]
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{DEG_list_DESeq2.pdf}
   \caption{Up and down regulated DEGs.}
   \label{fig:DEG_list_DESeq2}
\end{figure}

\subsubsection{DEG4: baySeq}
baySeq calculating estimated posterior likelihoods of differential expression (or more complex hypotheses) via empirical Bayesian methods \citep{Hardcastle2010}.
This approach begins by considering a distribution for the row defined by a set of underlying parameters for which some prior distribution exists. By estimating this prior distribution from the data, we are able to assess the posterior likelihood of the model.
<<eval=FALSE, keep.source=TRUE>>=
dim(countDFeByg)
bayseqDF <- run_BaySeq(countDFeByg, Comp3, number=27416)
write.table(bayseqDF, "results/bayseqDF.xls", col.names=NA, quote=FALSE, sep="\t")
pdf("./results/DEG_list_bayseqDF.pdf") 
DEG_list_bayseqDF <- filterDEG_FDR(degDF=bayseqDF, filter=c(FDR=1), method="BaySeq")
dev.off()
DEG_list_bayseqDF$Summary[1:4,]
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{DEG_list_bayseqDF.pdf}
   \caption{Up and down regulated DEGs.}
   \label{fig:DEG_list_bayseqDF}
\end{figure}

\subsubsection{DEG5: NBPSeq}
NBPSeq is a negative binomial (NB) models for two-group comparisons and regression inferences from RNA-Seq data \citep{Di2013}. There are several NBPseq test methods in the package. Here we try classic and generalized linear model corrected NBPseq methods. For these two methods, we create \Rfunction{run{\_}NBPSeq{\_}glm} and \Rfunction{run{\_}NBPSeq{\_}nbp} respectively.

NBPSeq.glm
For each row of the input data matrix, nb.glm.test fits an NB log-linear regression model and performs large-sample tests for a one-dimensional regression coefficient.
<<eval=FALSE, keep.source=TRUE>>=
NBPSeq.glmDF <- run_NBPSeq_glm (countDFeByg, Comp3)
write.table(NBPSeq.glmDF, "results/NBPSeq_glmDF.xls", col.names=NA, quote=FALSE, sep="\t")
pdf("./results/DEG_list_NBPSeq_glmDF.pdf")
DEG_list_NBPSeq.glmDF <- filterDEGnew(degDF=NBPSeq.glmDF, filter=c(Fold=2, FDR=1), method="NBPSeq.glm")
dev.off()
DEG_list_NBPSeq.glmDF$Summary[1:4,]
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{DEG_list_NBPSeq_glmDF.pdf}
   \caption{Up and down regulated DEGs.}
   \label{fig:DEG_list_NBPSeq.glmDF}
\end{figure}

NBPSeq.nbp.test
nbp.test fits an NBP model to the RNA-Seq counts and performs Robinson and Smyth's exact NB test on each gene to assess differential gene expression between two groups \citep{Robinson2008-sd}.
<<eval=FALSE, keep.source=TRUE>>=
NBPSeq.nbpDF <- run_NBPSeq_nbp (countDFeByg, Comp3)
write.table(NBPSeq.nbpDF, "results/NBPSeq.nbpDF.xls", col.names=NA, quote=FALSE, sep="\t")
pdf("./results/DEG_list_NBPSeq.nbpDF.pdf")
DEG_list_NBPSeq.nbpDF <- filterDEGnew(degDF=NBPSeq.nbpDF, filter=c(Fold=2, FDR=1), method="NBPSeq.nbp")
dev.off()
DEG_list_NBPSeq.nbpDF$Summary[1:4,]
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{DEG_list_NBPSeq_nbpDF.pdf}
   \caption{Up and down regulated DEGs.}
   \label{fig:DEG_list_NBPSeq.nbpDF}
\end{figure}

\subsubsection{DEG6: TSPM}
TSPM is a simple and powerful statistical approach, based on a two-stage Poisson model that extends the Poisson GLM and provides a powerful and flexible alternative for analyzing RNA-Seq data of moderately small sample sizes \cite{Auer2011-ko}. We create Rfunction{run{\_}TSPM} for compute all comparison.

<<eval=FALSE, keep.source=TRUE>>=
TSPMDF <- run_TSPM(countDFeByg, Comp3)
write.table(TSPMDF, "results/TSPMDF.xls", col.names=NA, quote=FALSE, sep="\t")
pdf("./results/DEG_list_TSPM.pdf")
DEG_list_TSPM <- filterDEGnew(degDF=TSPMDF, filter=c(Fold=2, FDR=1), method="TSPM")
dev.off()
DEG_list_TSPM$Summary[1:4,]
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{DEG_list_TSPM.pdf}
   \caption{Up and down regulated DEGs.}
   \label{fig:DEG_list_TSPM}
\end{figure}

\subsection{Comparisons}
In this section, we will introduce four strategies to compare results from various DEGs methods: Venn diagram, pair-wise Spearman's correlation coefficient, Area under ROC curve and correlation dendrogram. For Venn diagram, we use predicted up and down regulated DEGs in all paired-comparison samples. Readers can create Venn figure for specific paired-comparison by changing the setlist for plot. For correlation coefficient scatterplot, we compare results between methods for a specific paired-comparison based on logFC and FDR respectively. For ROC curve, we use logFC data in one paired-comparison.
\subsubsection{Total number of significantly differentially expressed}
<<eval=FALSE, keep.source=TRUE>>=
totalgenes <- system.file("extdata", "totalgenes.csv", package="DEG.comparison")
totalgenes <- read.delim (totalgenes, sep=",")
pdf("./results/TotalGenes.pdf")
plot <- ggplot(totalgenes, aes(Package, Number.of.significantly.differentially.expressed)) + geom_bar(aes(fill = DEG), stat="identity") + facet_wrap(~DEG, ncol=1)
print(plot) 
dev.off()
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{TotalGenes.pdf}
   \caption{Total number of significantly differentially expressed}
   \label{fig:TotalGenes}
\end{figure}

\subsubsection{List and data.frame with all DEG in all comparisons}
Before we construct Venn diagram for methods, we need to merge all up-regulated, down-regulated or total genes founded by seven methods into data frames, respectively. 
<<eval=FALSE, keep.source=TRUE>>=
###UporDown
List_RPKM_UporDown <- Reduce(union, (DEG_list_RPKM$UporDown))     
RPKM_UporDown <- data.frame(List_RPKM_UporDown); rownames(RPKM_UporDown) <- RPKM_UporDown[[1]]
List_edgeR_UporDown <- Reduce(union, (DEG_list_edgeR$UporDown))
edgeR_UporDown <- data.frame(List_edgeR_UporDown); rownames(edgeR_UporDown) <- edgeR_UporDown[[1]]
List_DESeq2_UporDown <- Reduce(union, (DEG_list_DESeq2$UporDown))
DESeq2_UporDown <- data.frame(List_DESeq2_UporDown); rownames(DESeq2_UporDown) <- DESeq2_UporDown[[1]]
List_bayseqDF_UporDown <- Reduce(union, (DEG_list_bayseqDF$UporDown))
bayseqDF_UporDown <- data.frame(List_bayseqDF_UporDown); rownames(bayseqDF_UporDown) <- bayseqDF_UporDown[[1]]
List_NBPSeq.glmDF_UporDown <- Reduce(union, (DEG_list_NBPSeq.glmDF$UporDown))
NBPSeq.glmDF_UporDown <- data.frame(List_NBPSeq.glmDF_UporDown); rownames(NBPSeq.glmDF_UporDown) <- NBPSeq.glmDF_UporDown[[1]]
List_NBPSeq.nbpDF_UporDown <- Reduce(union, (DEG_list_NBPSeq.nbpDF$UporDown))
NBPSeq.nbpDF_UporDown <- data.frame(List_NBPSeq.nbpDF_UporDown); rownames(NBPSeq.nbpDF_UporDown) <- NBPSeq.nbpDF_UporDown[[1]]
List_TSPM_UporDown <- Reduce(union, (DEG_list_TSPM$UporDown))
TSPM_UporDown <- data.frame(List_TSPM_UporDown); rownames(TSPM_UporDown) <- TSPM_UporDown[[1]]
###Up 
List_RPKM_Up <- Reduce(union, (DEG_list_RPKM$Up))     
RPKM_Up <- data.frame(List_RPKM_Up); rownames(RPKM_Up) <- RPKM_Up[[1]]
List_edgeR_Up <- Reduce(union, (DEG_list_edgeR$Up))
edgeR_Up <- data.frame(List_edgeR_Up); rownames(edgeR_Up) <- edgeR_Up[[1]]
List_DESeq2_Up <- Reduce(union, (DEG_list_DESeq2$Up))
DESeq2_Up <- data.frame(List_DESeq2_Up); rownames(DESeq2_Up) <- DESeq2_Up[[1]]
List_NBPSeq.glmDF_Up <- Reduce(union, (DEG_list_NBPSeq.glmDF$Up))
NBPSeq.glmDF_Up <- data.frame(List_NBPSeq.glmDF_Up); rownames(NBPSeq.glmDF_Up) <- NBPSeq.glmDF_Up[[1]]
List_NBPSeq.nbpDF_Up <- Reduce(union, (DEG_list_NBPSeq.nbpDF$Up))
NBPSeq.nbpDF_Up <- data.frame(List_NBPSeq.nbpDF_Up); rownames(NBPSeq.nbpDF_Up) <- NBPSeq.nbpDF_Up[[1]]
List_TSPM_Up <- Reduce(union, (DEG_list_TSPM$Up))
TSPM_Up <- data.frame(List_TSPM_Up); rownames(TSPM_Up) <- TSPM_Up[[1]]
###Down
List_RPKM_Down <- Reduce(union, (DEG_list_RPKM$Down))     
RPKM_Down <- data.frame(List_RPKM_Down); rownames(RPKM_Down) <- RPKM_Down[[1]]
List_edgeR_Down <- Reduce(union, (DEG_list_edgeR$Down))
edgeR_Down <- data.frame(List_edgeR_Down); rownames(edgeR_Down) <- edgeR_Down[[1]]
List_DESeq2_Down <- Reduce(union, (DEG_list_DESeq2$Down))
DESeq2_Down <- data.frame(List_DESeq2_Down); rownames(DESeq2_Down) <- DESeq2_Down[[1]]
List_NBPSeq.glmDF_Down <- Reduce(union, (DEG_list_NBPSeq.glmDF$Down))
NBPSeq.glmDF_Down <- data.frame(List_NBPSeq.glmDF_Down); rownames(NBPSeq.glmDF_Down) <- NBPSeq.glmDF_Down[[1]]
List_NBPSeq.nbpDF_Down <- Reduce(union, (DEG_list_NBPSeq.nbpDF$Down))
NBPSeq.nbpDF_Down <- data.frame(List_NBPSeq.nbpDF_Down); rownames(NBPSeq.nbpDF_Down) <- NBPSeq.nbpDF_Down[[1]]
List_TSPM_Down <- Reduce(union, (DEG_list_TSPM$Down))
TSPM_Down <- data.frame(List_TSPM_Down); rownames(TSPM_Down) <- TSPM_Down[[1]]   

@
\subsubsection{Venn diagram}
We union up-regulated or down-regulated data from different methods into setlists,respectively. Then perform Venn diagram for 5 methods without baySeq and RPKM. We exclude baySeq because the methods only show differentially expressed genes without up or down regulated label, and exclude RPKM because of over-sensitivity compare to other methods.
<<eval=FALSE, keep.source=TRUE>>=
##Up
setlist2 <- list(edgeR=rownames(edgeR_Up), DESeq2=rownames(DESeq2_Up), 
                 TSPM=rownames(TSPM_Up), NBPSeq.glm=rownames(NBPSeq.glmDF_Up), 
                 NBPSeq.nbp=rownames(NBPSeq.nbpDF_Up))
OLlist2 <- overLapper(setlist=setlist2, sep="_", type="vennsets")
counts2 <- sapply(OLlist2$Venn_List, length)
pdf("./results/Venn_diagram2.pdf")
vennPlot(counts=counts2, mymain="DEG Comparison Up")
dev.off()
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{Venn_diagram2.pdf}
   \caption{Venn diagram of the overlap in differentially up-regulated genes among five methods (excluding baySeq).}
   \label{fig:Venn_diagram2}
\end{figure}

<<eval=FALSE, keep.source=TRUE>>=
##Down
setlist4 <- list(edgeR=rownames(edgeR_Down), DESeq2=rownames(DESeq2_Down), 
                 TSPM=rownames(TSPM_Down), NBPSeq.glm=rownames(NBPSeq.glmDF_Down), 
                 NBPSeq.nbp=rownames(NBPSeq.nbpDF_Down))
OLlist4 <- overLapper(setlist=setlist4, sep="_", type="vennsets")
counts4 <- sapply(OLlist4$Venn_List, length)
pdf("./results/Venn_diagram4.pdf")
vennPlot(counts=counts4, mymain="DEG Comparison Down")
dev.off()
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{Venn_diagram4.pdf}
   \caption{Venn diagram of the overlap in differentially down-regulated genes among five methods (excluding baySeq).}
\end{figure}

We also construct a Venn plot for DEGs in paired-comparison between organs. The result shows that DEGs are various between organs paired-comparisons even in the same stage. 
<<eval=FALSE, keep.source=TRUE>>=
###Specific comparison
hh4<- (DEG_list_RPKM$Up$"AP1.4_AP3.4"); hh5<- (DEG_list_RPKM$Up$"AP1.4_AG.4"); hh6<- (DEG_list_RPKM$Up$"AP3.4_AG.4")
RPKMhh4 <- data.frame(hh4); rownames(RPKMhh4) <- RPKMhh4[[1]]
RPKMhh5 <- data.frame(hh5); rownames(RPKMhh5) <- RPKMhh5[[1]]
RPKMhh6 <- data.frame(hh6); rownames(RPKMhh6) <- RPKMhh6[[1]]

setlist6 <- list("AP1.4-AP3.4"=rownames(RPKMhh4), "AP1.4-AG.4"=rownames(RPKMhh5), "AP3.4-AG.4"=rownames(RPKMhh6))
OLlist6 <- overLapper(setlist=setlist6, sep="_", type="vennsets")
counts6 <- sapply(OLlist6$Venn_List, length)
pdf("./results/Venn_diagram_RPKM.pdf")
vennPlot(counts=counts6, mymain="DEG Comparison RPKM")
dev.off()
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{Venn_diagram_RPKM.pdf}
   \caption{Venn diagram of the overlap in differentially genes among different comparisons in RPKM. }
   \label{fig:Venn_diagram_RPKM}
\end{figure}

\subsubsection{Scatterplot}
Spearman's correlation coefficient is a nonparametric measure of statistical dependence between two variables. It assesses how well the relationship between two variables can be described using a monotonic function. Here we build a paired-wise scatterplot based on fold change and FDR of genes in AG-67 compare to AP3-67 that show correlation between methods.

<<eval=FALSE, keep.source=TRUE>>=
###Data: scatterDEG
RPKM.S <- data.frame(RPKM_FC[unlist(List_RPKM_UporDown),])
bayseq.S <- data.frame(bayseqDF [unlist(List_bayseqDF_UporDown),])
edgeR.S <- data.frame(edgeDF[unlist(List_edgeR_UporDown),])
NBPSeq.glm.S <- data.frame(NBPSeq.glmDF[unlist(List_NBPSeq.glmDF_UporDown),])
deseq2.S <- data.frame(deseq2DF[unlist(List_DESeq2_UporDown),]) 
TSPM.S <- data.frame(TSPMDF [unlist(List_TSPM_UporDown),])
NBPSeq.nbp.S <- data.frame(NBPSeq.nbpDF[unlist(List_NBPSeq.nbpDF_UporDown),])
@

<<eval=FALSE, keep.source=TRUE>>=
##logFC
RPKM.logFC <- data.frame(rownames(RPKM.S), RPKM.S$"AP3.67_AG.67_logFC", row.names=1) 
edgeR.logFC <- data.frame(rownames(edgeR.S), edgeR.S$"AP3.67.AG.67_logFC", row.names=1)
deseq2.logFC <- data.frame(rownames(deseq2.S), deseq2.S$"AP3.67.AG.67_logFC" , row.names=1)
NBPSeq.glm.logFC <- data.frame(rownames(NBPSeq.glm.S), NBPSeq.glm.S$"AP3.67_AG.67_logFC" , row.names=1)
NBPSeq.nbp.logFC <- data.frame(rownames(NBPSeq.nbp.S), NBPSeq.nbp.S$"AP3.67_AG.67_logFC" , row.names=1)
TSPM.logFC <- data.frame(rownames(TSPM.S), TSPM.S$"AP3.67_AG.67_logFC", row.names=1)  
      
scatterDEG1 <- merge(edgeR.logFC, deseq2.logFC, by='row.names', all=TRUE); rownames(scatterDEG1) <- scatterDEG1[[1]] ; scatterDEG1 <- scatterDEG1 [,-1]
scatterDEG2 <- merge(scatterDEG1, RPKM.logFC , by='row.names', all=TRUE); rownames(scatterDEG2) <- scatterDEG2[[1]] ; scatterDEG2 <- scatterDEG2 [,-1]
scatterDEG3 <- merge(scatterDEG2, NBPSeq.glm.logFC, by='row.names', all=TRUE); rownames(scatterDEG3) <- scatterDEG3[[1]] ; scatterDEG3 <- scatterDEG3 [,-1]
scatterDEG4 <- merge(scatterDEG3, NBPSeq.nbp.logFC, by='row.names', all=TRUE); rownames(scatterDEG4) <- scatterDEG4[[1]] ; scatterDEG4 <- scatterDEG4 [,-1]
scatterDEG5 <- merge(scatterDEG4, TSPM.logFC, by='row.names', all=TRUE); rownames(scatterDEG5) <- scatterDEG5[[1]] ; scatterDEG5 <- scatterDEG5 [,-1]
scatterDEG_logFC <- scatterDEG5
colnames(scatterDEG_logFC) <- c("edgeR", "DESeq2", "RPKM", "NBPSeq.glm", "NBPSeq.nbp", "TSPM")
scatterDEG_logFC[is.na(scatterDEG_logFC)] <- 0 

###Scatterplot
scatterDEG_logFC[1:4,]
pdf("./results/Scatterplot_AP367_AG67_logFC.pdf")
pairs(scatterDEG_logFC, lower.panel=panel.smooth, upper.panel=panel.cor, pch=20, main="Scatterplot Matrix log_FC")
dev.off()
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{Scatterplot_AP367_AG67_logFC.pdf}
   \caption{Pair-wise Spearman's correlation coefficients of fold change computed among six methods.}
   \label{fig:Scatterplot_AP3.67_AG.67_logFC}
\end{figure}

<<eval=FALSE, keep.source=TRUE>>=
##FDR   
bayseqFDR <- data.frame(rownames(bayseq.S), bayseq.S$"AP3.67_AG.67_FDR", row.names=1) 
edgeRFDR <- data.frame(rownames(edgeR.S), edgeR.S$"AP3.67.AG.67_FDR", row.names=1)
deseq2FDR <- data.frame(rownames(deseq2.S), deseq2.S$"AP3.67.AG.67_FDR" , row.names=1)
NBPSeq.glmFDR <- data.frame(rownames(NBPSeq.glm.S), NBPSeq.glm.S$"AP3.67_AG.67_FDR" , row.names=1)
NBPSeq.nbpFDR <- data.frame(rownames(NBPSeq.nbp.S), NBPSeq.nbp.S$"AP3.67_AG.67_FDR" , row.names=1)
TSPMFDR <- data.frame(rownames(TSPM.S), TSPM.S$"AP3.67_AG.67_FDR", row.names=1)  
      
scatterDEG1 <- merge(edgeRFDR, deseq2FDR, by='row.names', all=TRUE); rownames(scatterDEG1) <- scatterDEG1[[1]] ; scatterDEG1 <- scatterDEG1 [,-1]
scatterDEG2 <- merge(scatterDEG1, bayseqFDR, by='row.names', all=TRUE); rownames(scatterDEG2) <- scatterDEG2[[1]] ; scatterDEG2 <- scatterDEG2 [,-1]
scatterDEG3 <- merge(scatterDEG2, NBPSeq.glmFDR, by='row.names', all=TRUE); rownames(scatterDEG3) <- scatterDEG3[[1]] ; scatterDEG3 <- scatterDEG3 [,-1]
scatterDEG4 <- merge(scatterDEG3, NBPSeq.nbpFDR, by='row.names', all=TRUE); rownames(scatterDEG4) <- scatterDEG4[[1]] ; scatterDEG4 <- scatterDEG4 [,-1]
scatterDEG5 <- merge(scatterDEG4, TSPMFDR, by='row.names', all=TRUE); rownames(scatterDEG5) <- scatterDEG5[[1]] ; scatterDEG5 <- scatterDEG5 [,-1]
      
scatterDEG_FDR <- scatterDEG5
colnames(scatterDEG_FDR) <- c("edgeR", "DESeq2", "baySeq", "NBPSeq.glm", "NBPSeq.nbp", "TSPM")
scatterDEG_FDR[is.na(scatterDEG_FDR)] <- 1

###Scatterplot
scatterDEG_FDR[1:4,]
pdf("./results/Scatterplot_AP367_AG67_FDR.pdf")
pairs(scatterDEG_FDR, lower.panel=panel.smooth, upper.panel=panel.cor, pch=20, main="Scatterplot Matrix FDR")
dev.off()
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{Scatterplot_AP367_AG67_FDR.pdf}
   \caption{Pair-wise Spearman's correlation coefficients of FRD computed among six methods.}
   \label{fig:Scatterplot_AP3.67_AG.67_FDR}
\end{figure}

From logFC scatterplot figure, we can say edgeR is highly correlated with DESeq2, a possible reason could be the same negative binominal distribuction model that they based on. NBPSeq.glm and classic NBPSeq have similar DEGs results because they both derive from NBPSeq method.

\subsubsection{ROC Curve}
Receiver operating characteristic (ROC), or ROC curve, is a graphical plot that illustrates the performance of a binary classifier system as its discrimination threshold is varied. The curve is created by plotting the true positive rate against the false positive rate at various threshold settings. For TPR and FPR calculation, we need to give true results compare to predicted results from methods. So we set results from edgeR as the true results. 

Firstly, we need to construct a data frame containing fold change data and another data frame containing binary data that assigning significant genes as 1 and non-significant genes as 0.
  
<<eval=FALSE, keep.source=TRUE>>=
##Data
data.ROC <- scatterDEG5
scatterDEG1[is.na(scatterDEG1)] <- 1; 
data.ROC <- merge(data.ROC, tmp[1], by='row.names', all=TRUE ); rownames(data.ROC) <- data.ROC[[1]] ; data.ROC <- data.ROC [,-1]
colnames(data.ROC) <- c("edgeR", "DESeq2", "Bayseq", "NBPSeq.glm", "NBPSeq.nbp", "TSPM", "Common")
write.table(data.ROC, "results/data_ROC.xls", col.names=NA, quote=FALSE, sep="\t")
      
data.class <- data.ROC
data.class[!is.na(data.class)] <- 0
data.class[is.na(data.class)] <- 1
write.table(data.class, "results/data.class.xls", col.names=NA, quote=FALSE, sep="\t")
      
data.ROC1 <- data.ROC
data.ROC1[,1:7][is.na(data.ROC1[,1:7])] <- 1 
@
Here we use \Rpackage{ROCR} to draw ROC curves of methods in one figure.
<<eval=FALSE, keep.source=TRUE>>=
### ROCR
pdf("./results/ROC.pdf")
pred1 <- prediction(data.ROC1$Common, data.class$edgeR)
perf1 <- performance(pred1, "tpr", "fpr")
plot(perf1, avg= "threshold", col="black", lty=4,lwd= 2, main= "ROC curves compare with edgeR")
par(new = TRUE)
pred2 <- prediction(data.ROC1$Common, data.class$Bayseq)
perf2 <- performance(pred2, "tpr", "fpr")
plot(perf2, avg= "threshold", lty=4, lwd= 2, col="dodgerblue4")
par(new = TRUE)
pred3 <- prediction(data.ROC1$Common, data.class$NBPSeq.glm)
perf3 <- performance(pred3, "tpr", "fpr")
plot(perf3, avg= "threshold",  lty=4,lwd= 2, col="darkgreen")
par(new = TRUE)
pred4 <- prediction(data.ROC1$Common, data.class$NBPSeq.nbp)
perf4 <- performance(pred4, "tpr", "fpr")
plot(perf4, avg= "threshold",  lty=4,lwd= 2, col="darkviolet")
par(new = TRUE)
pred5 <- prediction(data.ROC1$Common, data.class$TSPM)
perf5 <- performance(pred5, "tpr", "fpr")
plot(perf5, avg= "threshold", lty=4, lwd= 2, col="firebrick")
par(new = TRUE)
pred6 <- prediction(data.ROC1$Common, data.class$DESeq2)
perf6 <- performance(pred6, "tpr", "fpr")
plot(perf6, avg= "threshold",  lty=4,lwd= 2, col="deeppink1")
legend("bottomright", legend=c("edgeR / 1", "BaySeq / 0.749", "NBPSeq.glm / 0.533", "NBPSeq.nbp / 0.872 ", "TSPM / 0.623", "DESeq2 / 0.974"),
       col=c("black", "dodgerblue4", "darkgreen", "darkviolet", "firebrick", "deeppink1"), lty=4, lwd=3, bty="n")
 
dev.off()
@

The area under the ROC curve(AUC-ROC) is equal to the probability that a classifier will rank a randomly chosen positive instance higher than a randomly chosen negative one. Basically, AUC-ROC correspond to the efficiency of a statistical separation method. Larger AUC value means higher accuracy of the method. 
<<eval=FALSE, keep.source=TRUE>>=
##calculate AUC
auc.tmp1 <- performance(pred1,"auc"); auc1 <- as.numeric(auc.tmp1@y.values)
auc.tmp2 <- performance(pred2,"auc"); auc2 <- as.numeric(auc.tmp2@y.values) 
auc.tmp3 <- performance(pred3,"auc"); auc3 <- as.numeric(auc.tmp3@y.values)
auc.tmp4 <- performance(pred4,"auc"); auc4 <- as.numeric(auc.tmp4@y.values) 
auc.tmp5 <- performance(pred5,"auc"); auc5 <- as.numeric(auc.tmp5@y.values)
auc.tmp6 <- performance(pred6,"auc"); auc6 <- as.numeric(auc.tmp6@y.values) 

@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{ROC.pdf}
   \caption{ROC curve}
   \label{fig:ROC}
\end{figure}

\subsubsection{Correlation dendrogram of methods}
<<eval=FALSE, keep.source=TRUE>>=
dFDR <- cor(data.ROC1, method="spearman")
hc1 <- hclust(as.dist(1-dFDR))
pdf("./results/methodsCorrelation_FDR.pdf")
plot.phylo(as.phylo(hc1), type="p", edge.col="blue", edge.width=2, show.node.label=TRUE,  main="Correlation FDR")
dev.off()
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{methodsCorrelation_FDR.pdf}
   \caption{Overall similarity between the methods based on Spearman correlation of gene ranks.}
   \label{fig:methodsCorrelation_FDR}
\end{figure}
<<eval=FALSE, keep.source=TRUE>>=
dlogFC <- cor(scatterDEG_logFC, method="spearman")
hc2 <- hclust(as.dist(1-dlogFC))
pdf("./results/methodsCorrelation_logFC.pdf")
plot.phylo(as.phylo(hc2), type="p", edge.col="blue", edge.width=2, show.node.label=TRUE, main="Correlation logFC")
dev.off()
@
\begin{figure}[H]
  \centering
   \includegraphics[width=10cm]{methodsCorrelation_logFC.pdf}
   \caption{Overall similarity between the methods based on Spearman correlation of gene ranks.}
   \label{fig:methodsCorrelation_logFC}
\end{figure}

\section{Version Information}
<<sessionInfo, results=tex, print=TRUE>>=
toLatex(sessionInfo())
@

\bibliography{bibtex}

\end{document}
